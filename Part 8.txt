배열

같은 형태의 많은 데이터를 반복문으로 처리하기 위해 메모리에 연속적으로 저장해놓고 쪼개는 방식을 사용.
->> 배열!!

배열의 선언
하나의 이름으로 한꺼번에 확보함
저장 공간의 개수와 상관없이 이름이 하나.
int ary[요소개수]

int ary[5]와 int, int ... int 5개의 차이점
전체 저장공간의 크기는 같음 -> 20byte ( 4 x 5byte)
하지만 메모리에 할당되는 방식이 다름
따로 선언하는 경우는 독립적인 저장 공간을 가지며 각각의 이름을 변수로 가짐
배열은 저장공간이 연속적으로 할당됨 -> 배열명이 전체 공간의 이름


배열의 사용
index를 통해 사용 [0~요소개수 -1]
사용범위를 초과한다면 ( 요소개수보다 더 큰 숫자를 요구한다면 ) 결과를 모름
-> 포인터 (메모리 위치에 요구를 하는 것)이기 때문에 거기에 값이 있으면 모르는 거임

초기화
배열을 선언만 한다면 다른 변수와 마찬가지로 쓰레기 값이 들어가있음
int ary[5] = {1, 2, ...}로 초기화를 해줄 수 잇음
만일 초기화하는 요소가 요소개수보다 적다면 {1, 2, 3} -> {1, 2, 3, 0, 0}이 됨

{0} 으로 떄리면 전부 {0, 0, ...}이 됨

배열의 개수를 생략했다면 초기화로 오는 배열 {1, 2, 3} 만큼만 할당되고 초기화됨

배열의 자료형에 맞추어서 초기화를 해주어야함

초기화는 처음만 가능하고 이후는 [] index로 따로 접근하여 값을 바꾸어 주어야함.

sizeof 를 이용한 배열처리
배열의 크기 ( 요소 개수)를 sieze 연산자를 이용하여 구할 수 있음 ( len )
siezeof(배열) / sizeof(배열[0])이 가능함.



문자를 저장하는 배열
char 형 배열 -> string
char형 배열의 선언과 초기화
** 문자의 길이보다 하나 크게 선언해야함
문자열이 끝났음을 알려주는 \0 (널문자)를 저장하기 때문에 필요함

다른 배열과 마찬가지로 초기화할때 초기화하는 값보다 남은 저장공간이 크다면 나머지를 0 (문자에서는 \0)로 채움

char arr[80] = "appalejam"이라고 초기화했을때
a p p l e j a m \0 \0 \0 \0 \0 \0...으로 배열이 초기화된다.
이떄 scanf("%s", arr); 로 grape가 입력되면
g r a p e \0 a m \0 \0 \0 \0 \0 ...이 된다고한다.
따라서 printf("%s", arr); 를 하면 \0까지인 grape만 출력됨


문자열 대입 ( 다른 문자열과 같이 문자만 대입은 가능 )
문자열에 대해서는 대입 연산자는 사용할 수 없음.
-> 이유: 배열명은 컴파일 과정에서 배열이 할당된 메모리의 주소값으로 변경되기 때문임. ( 그냥 상수임. )
- strcpy 함수는 메모리의 주소값에 접근하여 바꾸기 때문에 가능함.
따라서 strcpy라는 함수를 사용함.
char형의 새로운 문자열을 저장함
저장할 문자열의 길이를 파악해 딱 그길이만큼만 char형 배열에 문자열을 복사함


gets, puts 함수를 이용해 문자열을 쉽게 입,출력할 수 있음
하지만 배열의 크기를 확인하지 않으므로 이용에 주의해야함.