포인터

변수 선언으로 메모리에 공간을 확보하고.
변수명으로 메모리 공간을 식별했음.
-> 이는 선언된 블록; 함수 내부에서만 사용이 가능햇음
main함수 안에서;;;

메모리는 우리가 데이터를 넣고 꺼내는공간;
위치를 식별할 수 있어야함.
-> 변수명으로 식별해왔음
메모리의 위치를 주소값으로 식별할 수 있다.
주소값은 바이트 단위로 구별됨
2바이트 이상의 크기를 갖는 변수는 여러개의 주소값에 할당된다.
예_ int형 변수 a;
int a;
int는 4바이트이므로 4칸의 주소값에 할당됨

변수를 이름이 아닌 주소로 사용해보자.
주소는 변수가 할당된 메모리 공간의 시작주소를 의미함.
시작 주소를 알면 그 위치부터 변수의 크기만큼 메모리를 사용할 수 있따.
printf("%p", &a);로 주소를 알 수 있음

메모리의 주소가 필요할때마다 주소연산을 쓰는 것보다 주소를 저장해서
사용하면 편리함.

이 주소를 저장하는 변수가 포인터임.
포인터도 주소임. 선언하고 사용.

int *pa;
이때 자료형은 주소에 위치한 변수의 자료형을 적어야함.

이제 포인터 pa 는 변수a의 위치를 알려주고있기 때문에
pa -> a라고 표현함.
포인터가 가리키는 변수를 사용할 떄는 * 연산자(간접 참조 연산자)를 사용함

*pa == a

const는 예약어로 포인터에 사용하면 가리키는 변수의 값을 변경할 수 없다는 의미임
이 뜻은 *pa 로 a의 값을 변경할 수 없다는 뜻임.

sizeof를 사용하여 주소의 크기와 그 변수의 크기를 구할 수 있음
주소의 크기는 8바이트
*주소는 그에 해당하는 변수의 크기이다ㅣ.

포인터의 대입규칙
포인터가 가리키는 변수의 형태가 같아야함.
int *pa;
double *pd; 
int a;
pa = &a;
pd = pa를 사용하고 *pd를 호출하게 되면
a에 저장되어있는 값보다 더큰 메모리를 호출하게 되므로 숫자가 꺠짐

하지만 형변환을 사용한 포인터의 대입은 가능함.
(int *)이라는 형변환을 통해 저장도 가능함.
하지만 값은 바뀌게 됨...........