배열과 포인터의 관계

배열은 자료형이 같은 변수를 메모리에 연속으로 할당함
-> 일정한 간격으로 주소를 갖게됨(변수의 시작지점)
a[0] -> 100 (int)
a[1] -> 104

따라서 첫번째 주소를 알게되면 나머지 주소도 알 수 있음
컴파일러는 배열명을 컴파일 과정에서 첫번째 배열 요소의 주소로 변경함
그냥 printf(a)출력하면 주소가 나옴.


배열명으로 배열 요소 사용하기

위에서 배열명으로 출력하면 주소가 나옴.
여기서 *(배열명 + 1) 하면 a[1]과 같은 결과가 나옴
주소와 정수 연산시
주소 + (정수 * 주소를 구한 변수의 크기)
가 되어 연산되기 때문임

배열명 역할을 하는 포인터

int ary[3];
int *pa = ary;

하면 pa 와 ary는 같은 역할을 하게됨.
그냥 같은거임//

pa[2]= pa[0] + pa[1]
*(pa + 2) = *pa + *(pa + 1)
*(ary + 2) = *ary + *(ary + 1)
ary[2] = ary[0] + ary[1]
전부다 같은식임/

하지만 다른점도 많음.
sizeof연산의 결과
ary는 배열전체의 크기
포인터는 주소의 크기 8byte

변수와 상수의 차이
ary는 상수로 바꿀수 없음
포인터는 바꿀수 있음
--> 배열의 요소를 바꾸면서 포인터의 값이 바뀌므로 항상 유의 해야함/.

포인터의 뺄셈과 관계연산

가리키는 자료형이 같으면 포인터끼리의 뺄셈이 가능함.
포인터 - 포인터 -> 값의 차/ 가리키는 자료형의 크기
이는 메모리 상에서 두 주소가 자료형의 크기만큼 어느정도 먼 지를 알려줌

관계 연산은 순서를 알 수 있음



배열을 처리하는 함수
함수에서 배열을 처리하려면 어떻게 할까
인수로 포인터(주소)를 전달해주면 됨.

인수로 주소를 전달해주면 배열에 직접 간섭을 할수 있게 됨.
따라서 다른 변수를 만들지 않고 가능